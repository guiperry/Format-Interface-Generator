// Code generated by FormatModule tool. DO NOT EDIT.
package bmp

import (
	"encoding/binary" // Dynamically include each required import path

	"fmt" // Dynamically include each required import path

	"io" // Dynamically include each required import path
)

// InfoHeader represents the InfoHeader structure.
type InfoHeader struct {
	HeaderSize uint32 `` // Size of the information header (40)

	Width uint32 `` // Image width

	Height uint32 `` // Image height

	Planes uint16 `` // Number of color planes (always 1)

	BitsPerPixel uint16 `` // Bits per pixel (e.g., 24 for RGB)

	Compression uint32 `` // Compression method (0 for uncompressed)

	ImageSize uint32 `` // Size of the raw pixel data (can be 0 for uncompressed)

	XPixelsPerMeter int32 `` // Horizontal resolution (pixels per meter)

	YPixelsPerMeter int32 `` // Vertical resolution (pixels per meter)

	ColorsUsed uint32 `` // Number of colors in the color palette (0 for true-color images)

	ImportantColors uint32 `` // Number of important colors (0 for all colors important)

}

// Read populates the struct fields by reading from an io.Reader, using optional context.
// The context can be used by dynamic length calculations.
func (s *InfoHeader) Read(r io.Reader, ctx interface{}) error {
	var err error // Declare err only if needed for Read

	// Read HeaderSize (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.HeaderSize)
	if err != nil {
		return fmt.Errorf("reading HeaderSize (uint32): %w", err)
	}

	// Read Width (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.Width)
	if err != nil {
		return fmt.Errorf("reading Width (uint32): %w", err)
	}

	// Read Height (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.Height)
	if err != nil {
		return fmt.Errorf("reading Height (uint32): %w", err)
	}

	// Read Planes (uint16)

	err = binary.Read(r, binary.LittleEndian, &s.Planes)
	if err != nil {
		return fmt.Errorf("reading Planes (uint16): %w", err)
	}

	// Read BitsPerPixel (uint16)

	err = binary.Read(r, binary.LittleEndian, &s.BitsPerPixel)
	if err != nil {
		return fmt.Errorf("reading BitsPerPixel (uint16): %w", err)
	}

	// Read Compression (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.Compression)
	if err != nil {
		return fmt.Errorf("reading Compression (uint32): %w", err)
	}

	// Read ImageSize (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.ImageSize)
	if err != nil {
		return fmt.Errorf("reading ImageSize (uint32): %w", err)
	}

	// Read XPixelsPerMeter (int32)

	err = binary.Read(r, binary.LittleEndian, &s.XPixelsPerMeter)
	if err != nil {
		return fmt.Errorf("reading XPixelsPerMeter (int32): %w", err)
	}
	// Add other numeric types here if needed

	// Read YPixelsPerMeter (int32)

	err = binary.Read(r, binary.LittleEndian, &s.YPixelsPerMeter)
	if err != nil {
		return fmt.Errorf("reading YPixelsPerMeter (int32): %w", err)
	}
	// Add other numeric types here if needed

	// Read ColorsUsed (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.ColorsUsed)
	if err != nil {
		return fmt.Errorf("reading ColorsUsed (uint32): %w", err)
	}

	// Read ImportantColors (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.ImportantColors)
	if err != nil {
		return fmt.Errorf("reading ImportantColors (uint32): %w", err)
	}

	return nil // If we got here, all reads using 'err' were successful

}

// Write serializes the struct fields into an io.Writer.
func (s *InfoHeader) Write(w io.Writer) error {
	var err error // Declare err only if needed for Write

	// Write HeaderSize (uint32)

	err = binary.Write(w, binary.LittleEndian, s.HeaderSize)
	if err != nil {
		return fmt.Errorf("writing HeaderSize (uint32): %w", err)
	}

	// Write Width (uint32)

	err = binary.Write(w, binary.LittleEndian, s.Width)
	if err != nil {
		return fmt.Errorf("writing Width (uint32): %w", err)
	}

	// Write Height (uint32)

	err = binary.Write(w, binary.LittleEndian, s.Height)
	if err != nil {
		return fmt.Errorf("writing Height (uint32): %w", err)
	}

	// Write Planes (uint16)

	err = binary.Write(w, binary.LittleEndian, s.Planes)
	if err != nil {
		return fmt.Errorf("writing Planes (uint16): %w", err)
	}

	// Write BitsPerPixel (uint16)

	err = binary.Write(w, binary.LittleEndian, s.BitsPerPixel)
	if err != nil {
		return fmt.Errorf("writing BitsPerPixel (uint16): %w", err)
	}

	// Write Compression (uint32)

	err = binary.Write(w, binary.LittleEndian, s.Compression)
	if err != nil {
		return fmt.Errorf("writing Compression (uint32): %w", err)
	}

	// Write ImageSize (uint32)

	err = binary.Write(w, binary.LittleEndian, s.ImageSize)
	if err != nil {
		return fmt.Errorf("writing ImageSize (uint32): %w", err)
	}

	// Write XPixelsPerMeter (int32)

	err = binary.Write(w, binary.LittleEndian, s.XPixelsPerMeter)
	if err != nil {
		return fmt.Errorf("writing XPixelsPerMeter (int32): %w", err)
	}
	// Add other numeric types here if needed

	// Write YPixelsPerMeter (int32)

	err = binary.Write(w, binary.LittleEndian, s.YPixelsPerMeter)
	if err != nil {
		return fmt.Errorf("writing YPixelsPerMeter (int32): %w", err)
	}
	// Add other numeric types here if needed

	// Write ColorsUsed (uint32)

	err = binary.Write(w, binary.LittleEndian, s.ColorsUsed)
	if err != nil {
		return fmt.Errorf("writing ColorsUsed (uint32): %w", err)
	}

	// Write ImportantColors (uint32)

	err = binary.Write(w, binary.LittleEndian, s.ImportantColors)
	if err != nil {
		return fmt.Errorf("writing ImportantColors (uint32): %w", err)
	}

	return nil // If we got here, all writes using 'err' were successful

}
