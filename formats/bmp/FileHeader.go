// Code generated by FormatModule tool. DO NOT EDIT.
package bmp

import (
	"encoding/binary" // Dynamically include each required import path

	"fmt" // Dynamically include each required import path

	"io" // Dynamically include each required import path
)

// FileHeader represents the FileHeader structure.
type FileHeader struct {
	Signature string `` // BMP Signature (BMP)

	FileSize uint32 `` // Total file size

	Reserved1 uint16 `` // Reserved (0)

	Reserved2 uint16 `` // Reserved (0)

	DataOffset uint32 `` // Offset to image data

}

// Read populates the struct fields by reading from an io.Reader, using optional context.
// The context can be used by dynamic length calculations.
func (s *FileHeader) Read(r io.Reader, ctx interface{}) error {
	var err error // Declare err only if needed for Read
	var b []byte

	// Read Signature (string)

	b = make([]byte, 2)
	_, err = io.ReadFull(r, b)
	if err != nil {
		return fmt.Errorf("reading Signature (string[2]): %w", err)
	}
	s.Signature = string(b)

	// Read FileSize (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.FileSize)
	if err != nil {
		return fmt.Errorf("reading FileSize (uint32): %w", err)
	}

	// Read Reserved1 (uint16)

	err = binary.Read(r, binary.LittleEndian, &s.Reserved1)
	if err != nil {
		return fmt.Errorf("reading Reserved1 (uint16): %w", err)
	}

	// Read Reserved2 (uint16)

	err = binary.Read(r, binary.LittleEndian, &s.Reserved2)
	if err != nil {
		return fmt.Errorf("reading Reserved2 (uint16): %w", err)
	}

	// Read DataOffset (uint32)

	err = binary.Read(r, binary.LittleEndian, &s.DataOffset)
	if err != nil {
		return fmt.Errorf("reading DataOffset (uint32): %w", err)
	}

	return nil // If we got here, all reads using 'err' were successful

}

// Write serializes the struct fields into an io.Writer.
func (s *FileHeader) Write(w io.Writer) error {
	var err error // Declare err only if needed for Write

	// Write Signature (string)

	_, err = w.Write([]byte(s.Signature))
	if err != nil {
		return fmt.Errorf("writing Signature (string): %w", err)
	}
	// TODO: Add padding if fixed length string is required?

	// Write FileSize (uint32)

	err = binary.Write(w, binary.LittleEndian, s.FileSize)
	if err != nil {
		return fmt.Errorf("writing FileSize (uint32): %w", err)
	}

	// Write Reserved1 (uint16)

	err = binary.Write(w, binary.LittleEndian, s.Reserved1)
	if err != nil {
		return fmt.Errorf("writing Reserved1 (uint16): %w", err)
	}

	// Write Reserved2 (uint16)

	err = binary.Write(w, binary.LittleEndian, s.Reserved2)
	if err != nil {
		return fmt.Errorf("writing Reserved2 (uint16): %w", err)
	}

	// Write DataOffset (uint32)

	err = binary.Write(w, binary.LittleEndian, s.DataOffset)
	if err != nil {
		return fmt.Errorf("writing DataOffset (uint32): %w", err)
	}

	return nil // If we got here, all writes using 'err' were successful

}
