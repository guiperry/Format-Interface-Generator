// Code generated by FormatModule tool. DO NOT EDIT.
package jpg

import (
	"FormatModules/generator" // Dynamically include each required import path

	"encoding/binary" // Dynamically include each required import path

	"fmt" // Dynamically include each required import path

	"github.com/knetic/govaluate" // Dynamically include each required import path

	"io" // Dynamically include each required import path
)

// SOF0Payload represents the SOF0Payload structure.
type SOF0Payload struct {
	Precision uint8 `` // Sample precision (usually 8 bits)

	Height uint16 `` // Image height in pixels

	Width uint16 `` // Image width in pixels

	NumberOfComponents uint8 `` // Number of image components (e.g., 1 for grayscale, 3 for YCbCr)

	ComponentData []byte `` // Raw data for component specifications (ID, Sampling Factors, QT Index)

}

// Read populates the struct fields by reading from an io.Reader, using optional context.
// The context can be used by dynamic length calculations.
func (s *SOF0Payload) Read(r io.Reader, ctx interface{}) error {
	var err error // Declare err only if needed for Read

	var tmpUint8 uint8 // <-- Declare tmpUint8 once if needed

	// Read Precision (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle uint8
	// Use assignment '=' instead of 'var'
	err = binary.Read(r, binary.LittleEndian, &tmpUint8) // <-- Assign to existing tmpUint8
	if err != nil {
		return fmt.Errorf("reading Precision (uint8): %w", err)
	}
	s.Precision = tmpUint8
	// ... (other types like uint16, uint32 etc.) ...

	// Read Height (uint16)

	// ... (string, []byte, other numeric types logic remains the same) ...

	err = binary.Read(r, binary.LittleEndian, &s.Height)
	if err != nil {
		return fmt.Errorf("reading Height (uint16): %w", err)
	}

	// Read Width (uint16)

	// ... (string, []byte, other numeric types logic remains the same) ...

	err = binary.Read(r, binary.LittleEndian, &s.Width)
	if err != nil {
		return fmt.Errorf("reading Width (uint16): %w", err)
	}

	// Read NumberOfComponents (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle uint8
	// Use assignment '=' instead of 'var'
	err = binary.Read(r, binary.LittleEndian, &tmpUint8) // <-- Assign to existing tmpUint8
	if err != nil {
		return fmt.Errorf("reading NumberOfComponents (uint8): %w", err)
	}
	s.NumberOfComponents = tmpUint8
	// ... (other types like uint16, uint32 etc.) ...

	// Read ComponentData ([]byte)

	// ... (string, []byte, other numeric types logic remains the same) ...

	// Dynamic length []byte field: ComponentData using expression: s.NumberOfComponents * 3
	expressionStr := `s.NumberOfComponents * 3`
	expression, errExpr := govaluate.NewEvaluableExpressionWithFunctions(expressionStr, generator.GetExpressionFunctions()) // Use helpers
	if errExpr != nil {
		return fmt.Errorf("parsing length expression for ComponentData ('%s'): %w", expressionStr, errExpr)
	}
	parameters := map[string]interface{}{"s": s, "ctx": ctx}
	evalResult, errEval := expression.Evaluate(parameters)
	if errEval != nil {
		return fmt.Errorf("evaluating length expression for ComponentData ('%s'): %w", expressionStr, errEval)
	}
	var size int
	switch v := evalResult.(type) { // Type conversion logic
	case float64:
		size = int(v)
	case float32:
		size = int(v)
	case int:
		size = v
	case int64:
		size = int(v)
	case int32:
		size = int(v)
	case uint:
		size = int(v)
	case uint64:
		size = int(v)
	case uint32:
		size = int(v)
	case uint16:
		size = int(v)
	case uint8:
		size = int(v)
	default:
		return fmt.Errorf("length expression for ComponentData ('%s') evaluated to non-numeric type %T", expressionStr, evalResult)
	}
	if size < 0 {
		return fmt.Errorf("length expression for ComponentData ('%s') evaluated to negative size %d", expressionStr, size)
	}
	s.ComponentData = make([]byte, size)
	_, err = io.ReadFull(r, s.ComponentData)
	if err != nil {
		return fmt.Errorf("reading ComponentData ([]byte[dynamic length %s]): %w", expressionStr, err)
	}

	return nil // If we got here, all reads using 'err' were successful

}

// Write serializes the struct fields into an io.Writer.
func (s *SOF0Payload) Write(w io.Writer) error {
	var err error // Declare err only if needed for Write
	// NOTE: tmpUint8 is not needed for Write method as we write directly from s.FieldName

	// Write Precision (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle numeric types
	err = binary.Write(w, binary.LittleEndian, s.Precision) // Write directly
	if err != nil {
		return fmt.Errorf("writing Precision (uint8): %w", err)
	}
	// ... (other types like uint16, uint32 etc.) ...

	// Write Height (uint16)

	// ... (string, []byte, other numeric types logic remains the same) ...

	err = binary.Write(w, binary.LittleEndian, s.Height)
	if err != nil {
		return fmt.Errorf("writing Height (uint16): %w", err)
	}

	// Write Width (uint16)

	// ... (string, []byte, other numeric types logic remains the same) ...

	err = binary.Write(w, binary.LittleEndian, s.Width)
	if err != nil {
		return fmt.Errorf("writing Width (uint16): %w", err)
	}

	// Write NumberOfComponents (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle numeric types
	err = binary.Write(w, binary.LittleEndian, s.NumberOfComponents) // Write directly
	if err != nil {
		return fmt.Errorf("writing NumberOfComponents (uint8): %w", err)
	}
	// ... (other types like uint16, uint32 etc.) ...

	// Write ComponentData ([]byte)

	// ... (string, []byte, other numeric types logic remains the same) ...

	_, err = w.Write(s.ComponentData)
	if err != nil {
		return fmt.Errorf("writing ComponentData ([]byte): %w", err)
	}

	return nil // If we got here, all writes using 'err' were successful

}
