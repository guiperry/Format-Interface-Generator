// Code generated by FormatModule tool. DO NOT EDIT.
package jpg

import (
	"encoding/binary" // Dynamically include each required import path

	"fmt" // Dynamically include each required import path

	"io" // Dynamically include each required import path
)

// APP0Payload represents the APP0Payload structure.
type APP0Payload struct {
	Identifier string `` // Should be 'JFIF' followed by a null terminator

	VersionMajor uint8 `` // JFIF Major version number

	VersionMinor uint8 `` // JFIF Minor version number

	DensityUnits uint8 `` // Units for Xdensity and Ydensity (0: no units, 1: pixels per inch, 2: pixels per cm)

	Xdensity uint16 `` // Horizontal pixel density

	Ydensity uint16 `` // Vertical pixel density

	Xthumbnail uint8 `` // Thumbnail horizontal pixel count

	Ythumbnail uint8 `` // Thumbnail vertical pixel count

}

// Read populates the struct fields by reading from an io.Reader, using optional context.
// The context can be used by dynamic length calculations.
func (s *APP0Payload) Read(r io.Reader, ctx interface{}) error {
	var err error // Declare err only if needed for Read
	var b []byte
	var tmpUint8 uint8 // <-- Declare tmpUint8 once if needed

	// Read Identifier (string)

	// ... (string, []byte, other numeric types logic remains the same) ...

	b = make([]byte, 5)
	_, err = io.ReadFull(r, b)
	if err != nil {
		return fmt.Errorf("reading Identifier (string[5]): %w", err)
	}
	s.Identifier = string(b)

	// Read VersionMajor (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle uint8
	// Use assignment '=' instead of 'var'
	err = binary.Read(r, binary.LittleEndian, &tmpUint8) // <-- Assign to existing tmpUint8
	if err != nil {
		return fmt.Errorf("reading VersionMajor (uint8): %w", err)
	}
	s.VersionMajor = tmpUint8
	// ... (other types like uint16, uint32 etc.) ...

	// Read VersionMinor (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle uint8
	// Use assignment '=' instead of 'var'
	err = binary.Read(r, binary.LittleEndian, &tmpUint8) // <-- Assign to existing tmpUint8
	if err != nil {
		return fmt.Errorf("reading VersionMinor (uint8): %w", err)
	}
	s.VersionMinor = tmpUint8
	// ... (other types like uint16, uint32 etc.) ...

	// Read DensityUnits (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle uint8
	// Use assignment '=' instead of 'var'
	err = binary.Read(r, binary.LittleEndian, &tmpUint8) // <-- Assign to existing tmpUint8
	if err != nil {
		return fmt.Errorf("reading DensityUnits (uint8): %w", err)
	}
	s.DensityUnits = tmpUint8
	// ... (other types like uint16, uint32 etc.) ...

	// Read Xdensity (uint16)

	// ... (string, []byte, other numeric types logic remains the same) ...

	err = binary.Read(r, binary.LittleEndian, &s.Xdensity)
	if err != nil {
		return fmt.Errorf("reading Xdensity (uint16): %w", err)
	}

	// Read Ydensity (uint16)

	// ... (string, []byte, other numeric types logic remains the same) ...

	err = binary.Read(r, binary.LittleEndian, &s.Ydensity)
	if err != nil {
		return fmt.Errorf("reading Ydensity (uint16): %w", err)
	}

	// Read Xthumbnail (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle uint8
	// Use assignment '=' instead of 'var'
	err = binary.Read(r, binary.LittleEndian, &tmpUint8) // <-- Assign to existing tmpUint8
	if err != nil {
		return fmt.Errorf("reading Xthumbnail (uint8): %w", err)
	}
	s.Xthumbnail = tmpUint8
	// ... (other types like uint16, uint32 etc.) ...

	// Read Ythumbnail (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle uint8
	// Use assignment '=' instead of 'var'
	err = binary.Read(r, binary.LittleEndian, &tmpUint8) // <-- Assign to existing tmpUint8
	if err != nil {
		return fmt.Errorf("reading Ythumbnail (uint8): %w", err)
	}
	s.Ythumbnail = tmpUint8
	// ... (other types like uint16, uint32 etc.) ...

	return nil // If we got here, all reads using 'err' were successful

}

// Write serializes the struct fields into an io.Writer.
func (s *APP0Payload) Write(w io.Writer) error {
	var err error // Declare err only if needed for Write
	// NOTE: tmpUint8 is not needed for Write method as we write directly from s.FieldName

	// Write Identifier (string)

	// ... (string, []byte, other numeric types logic remains the same) ...

	_, err = w.Write([]byte(s.Identifier))
	if err != nil {
		return fmt.Errorf("writing Identifier (string): %w", err)
	}
	// TODO: Add padding if fixed length string is required?

	// Write VersionMajor (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle numeric types
	err = binary.Write(w, binary.LittleEndian, s.VersionMajor) // Write directly
	if err != nil {
		return fmt.Errorf("writing VersionMajor (uint8): %w", err)
	}
	// ... (other types like uint16, uint32 etc.) ...

	// Write VersionMinor (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle numeric types
	err = binary.Write(w, binary.LittleEndian, s.VersionMinor) // Write directly
	if err != nil {
		return fmt.Errorf("writing VersionMinor (uint8): %w", err)
	}
	// ... (other types like uint16, uint32 etc.) ...

	// Write DensityUnits (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle numeric types
	err = binary.Write(w, binary.LittleEndian, s.DensityUnits) // Write directly
	if err != nil {
		return fmt.Errorf("writing DensityUnits (uint8): %w", err)
	}
	// ... (other types like uint16, uint32 etc.) ...

	// Write Xdensity (uint16)

	// ... (string, []byte, other numeric types logic remains the same) ...

	err = binary.Write(w, binary.LittleEndian, s.Xdensity)
	if err != nil {
		return fmt.Errorf("writing Xdensity (uint16): %w", err)
	}

	// Write Ydensity (uint16)

	// ... (string, []byte, other numeric types logic remains the same) ...

	err = binary.Write(w, binary.LittleEndian, s.Ydensity)
	if err != nil {
		return fmt.Errorf("writing Ydensity (uint16): %w", err)
	}

	// Write Xthumbnail (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle numeric types
	err = binary.Write(w, binary.LittleEndian, s.Xthumbnail) // Write directly
	if err != nil {
		return fmt.Errorf("writing Xthumbnail (uint8): %w", err)
	}
	// ... (other types like uint16, uint32 etc.) ...

	// Write Ythumbnail (uint8)

	// ... (string, []byte, other numeric types logic remains the same) ...
	// Handle numeric types
	err = binary.Write(w, binary.LittleEndian, s.Ythumbnail) // Write directly
	if err != nil {
		return fmt.Errorf("writing Ythumbnail (uint8): %w", err)
	}
	// ... (other types like uint16, uint32 etc.) ...

	return nil // If we got here, all writes using 'err' were successful

}
