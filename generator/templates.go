package generator

// StructTemplate stores the Go code template for the struct
var StructTemplate = `// Code generated by FormatModule tool. DO NOT EDIT.
package {{.PackageName}}

import (
	{{range .Imports}}"{{.}}"
	{{end}}
)

// {{.StructName}} represents the {{.StructName}} structure.
type {{.StructName}} struct {
    {{range .Fields}}
    {{.Name}} {{.Type}} // {{.Description}}
    {{end}}
}

// Read populates the struct fields by reading from an io.Reader.
func (s *{{.StructName}}) Read(r io.Reader) error {
	{{if .NeedsErrVarRead}}var err error{{end}} // Declare err only if needed for Read
	{{if .NeedsBVar}}var b []byte{{end}}

    {{range $index, $field := .Fields}}
	// Read {{$field.Name}} ({{$field.Type}})
	{{if isConditional $field}}
	// Conditional field: {{$field.Name}}
	if {{generateConditionCheck $field.Condition}} {
		{{if eq $field.Type "string"}}
			{{if $field.Length}}
				{{if isExpressionLength $field}}
		// Dynamic length string field: {{$field.Name}}
		size := int({{$field.Length}}) // Calculate length from expression
		b = make([]byte, size)
		_, err = io.ReadFull(r, b) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (string[dynamic length {{$field.Length}}]): %w", err)
		}
		s.{{$field.Name}} = string(b)
				{{else}}
					{{$length := $field.Length | atoi}}
					{{if gt $length 0}}
		b = make([]byte, {{$length}})
		_, err = io.ReadFull(r, b) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (string[{{$length}}]): %w", err)
		}
		s.{{$field.Name}} = string(b)
					{{else}}
		return fmt.Errorf("invalid length {{$length}} for conditional string field {{$field.Name}}") // Returns early
					{{end}}
				{{end}}
			{{else}}
		return fmt.Errorf("cannot automatically read conditional string field {{$field.Name}} without a defined length") // Returns early
			{{end}}
		{{else if eq $field.Type "uint8"}}
		var {{$field.Name}}_uint8 uint8
		err = binary.Read(r, binary.LittleEndian, &{{$field.Name}}_uint8) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (uint8): %w", err)
		}
		s.{{$field.Name}} = {{$field.Name}}_uint8
		{{else if eq $field.Type "uint16"}}
		err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (uint16): %w", err)
		}
		{{else if eq $field.Type "uint32"}}
		err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (uint32): %w", err)
		}
		{{else if eq $field.Type "int32"}}
		err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (int32): %w", err)
		}
		{{else if eq $field.Type "[]byte"}}
			{{if $field.Length}}
				{{if isExpressionLength $field}}
		// Dynamic length []byte field: {{$field.Name}}
		size := int({{$field.Length}}) // Calculate length from expression
		s.{{$field.Name}} = make([]byte, size)
		_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} ([]byte[dynamic length {{$field.Length}}]): %w", err)
		}
				{{else}}
					{{$length := $field.Length | atoi}}
					{{if gt $length 0}}
		s.{{$field.Name}} = make([]byte, {{$length}})
		_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} ([]byte[{{$length}}]): %w", err)
		}
					{{else}}
		return fmt.Errorf("invalid length {{$length}} for conditional []byte field {{$field.Name}}") // Returns early
					{{end}}
				{{end}}
			{{else}}
		// This field cannot be read automatically.
		return fmt.Errorf("cannot automatically read conditional []byte field {{$field.Name}} without a defined length") // Returns early
			{{end}}
		{{else}}
		// Unsupported type: {{$field.Type}} for conditional field {{$field.Name}}
		return fmt.Errorf("unsupported type '%s' for conditional field {{$field.Name}} in Read method", "{{$field.Type}}") // Returns early
		{{end}}
	}
	{{else}}
	{{if eq $field.Type "string"}}
		{{if $field.Length}}
			{{if isExpressionLength $field}}
	// Dynamic length string field: {{$field.Name}}
	size := int({{$field.Length}}) // Calculate length from expression
	b = make([]byte, size)
	_, err = io.ReadFull(r, b) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (string[dynamic length {{$field.Length}}]): %w", err)
	}
	s.{{$field.Name}} = string(b)
			{{else}}
				{{$length := $field.Length | atoi}}
				{{if gt $length 0}}
	b = make([]byte, {{$length}})
	_, err = io.ReadFull(r, b) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (string[{{$length}}]): %w", err)
	}
	s.{{$field.Name}} = string(b)
				{{else}}
	return fmt.Errorf("invalid length {{$length}} for string field {{$field.Name}}") // Returns early
				{{end}}
			{{end}}
		{{else}}
	return fmt.Errorf("cannot automatically read string field {{$field.Name}} without a defined length") // Returns early
		{{end}}
	{{else if eq $field.Type "uint8"}}
	var {{$field.Name}}_uint8 uint8
	err = binary.Read(r, binary.LittleEndian, &{{$field.Name}}_uint8) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint8): %w", err)
	}
	s.{{$field.Name}} = {{$field.Name}}_uint8
	{{else if eq $field.Type "uint16"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint16): %w", err)
	}
	{{else if eq $field.Type "uint32"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint32): %w", err)
	}
	{{else if eq $field.Type "int32"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (int32): %w", err)
	}
	{{else if eq $field.Type "[]byte"}}
		{{if $field.Length}}
			{{if isExpressionLength $field}}
	// Dynamic length []byte field: {{$field.Name}}
	size := int({{$field.Length}}) // Calculate length from expression
	s.{{$field.Name}} = make([]byte, size)
	_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} ([]byte[dynamic length {{$field.Length}}]): %w", err)
	}
			{{else}}
				{{$length := $field.Length | atoi}}
				{{if gt $length 0}}
	s.{{$field.Name}} = make([]byte, {{$length}})
	_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} ([]byte[{{$length}}]): %w", err)
	}
				{{else}}
	return fmt.Errorf("invalid length {{$length}} for []byte field {{$field.Name}}") // Returns early
				{{end}}
			{{end}}
		{{else}}
	// This field cannot be read automatically.
	return fmt.Errorf("cannot automatically read []byte field {{$field.Name}} without a defined length") // Returns early
		{{end}}
	{{else}}
	// Unsupported type: {{$field.Type}} for field {{$field.Name}}
	return fmt.Errorf("unsupported type '%s' for field {{$field.Name}} in Read method", "{{$field.Type}}") // Returns early
	{{end}}
	{{end}}
    {{end}}

	{{/* Final return nil logic:
	     - If NeedsErrVar is true, it means some operation might have succeeded, so we need return nil.
	     - If NeedsErrVar is false, it means either:
	         a) There were no fields at all.
	         b) All fields generated code that returned early.
	     We need 'return nil' only for case (a).
	*/}}
	{{if .NeedsErrVarRead}}
	// If we reached here, operations using 'err' were successful.
	return nil
	{{else if not .Fields}}
	// No fields in the struct, Read is trivially successful.
	return nil
	{{end}}
	{{/* Implicit: If not .NeedsErrVar and Fields exist, all paths returned early, so no final return nil needed. */}}
}

// Write serializes the struct fields into an io.Writer.
func (s *{{.StructName}}) Write(w io.Writer) error {
	{{if .NeedsErrVarWrite}}var err error{{end}} // Declare err only if needed for Write

    {{range $index, $field := .Fields}}
	// Write {{$field.Name}} ({{$field.Type}})
	{{if isConditional $field}}
	// Conditional field: {{$field.Name}}
	if {{generateConditionCheck $field.Condition}} {
		{{if eq $field.Type "string"}}
		_, err = w.Write([]byte(s.{{$field.Name}})) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (string): %w", err)
		}
		// TODO: Add padding if fixed length string is required?
		{{else if eq $field.Type "uint8"}}
		err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (uint8): %w", err)
		}
		{{else if eq $field.Type "uint16"}}
		err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (uint16): %w", err)
		}
		{{else if eq $field.Type "uint32"}}
		err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (uint32): %w", err)
		}
		{{else if eq $field.Type "int32"}}
		err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (int32): %w", err)
		}
		{{else if eq $field.Type "[]byte"}}
		_, err = w.Write(s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} ([]byte): %w", err)
		}
		{{else}}
		return fmt.Errorf("unsupported type '%s' for conditional field {{$field.Name}} in Write method", "{{$field.Type}}") // Returns early
		{{end}}
	}
	{{else}}
	{{if eq $field.Type "string"}}
	_, err = w.Write([]byte(s.{{$field.Name}})) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (string): %w", err)
	}
	// TODO: Add padding if fixed length string is required?
	{{else if eq $field.Type "uint8"}}
	err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (uint8): %w", err)
	}
	{{else if eq $field.Type "uint16"}}
	err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (uint16): %w", err)
	}
	{{else if eq $field.Type "uint32"}}
	err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (uint32): %w", err)
	}
	{{else if eq $field.Type "int32"}}
	err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (int32): %w", err)
	}
	{{else if eq $field.Type "[]byte"}}
	_, err = w.Write(s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} ([]byte): %w", err)
	}
	{{else}}
	return fmt.Errorf("unsupported type '%s' for field {{$field.Name}} in Write method", "{{$field.Type}}") // Returns early
	{{end}}
	{{end}}
    {{end}}

	{{/* Same final return nil logic for Write */}}
	{{if .NeedsErrVarWrite}}
	return nil
	{{else if not .Fields}}
	return nil
	{{end}}
}
`
