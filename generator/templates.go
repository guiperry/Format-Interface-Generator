package generator

// StructTemplate stores the Go code template for the struct
var StructTemplate = `// Code generated by FormatModule tool. DO NOT EDIT.
package {{.PackageName}}

import (
	{{range .Imports}}"{{.}}"
	{{end}}
)

// {{.StructName}} represents the {{.StructName}} structure.
type {{.StructName}} struct {
    {{range .Fields}}
    {{.Name}} {{.Type}} // {{.Description}}
    {{end}}
}

// Read populates the struct fields by reading from an io.Reader.
func (s *{{.StructName}}) Read(r io.Reader) error {
	{{if .NeedsErrVarRead}}var err error{{end}} // Declare err only if needed for Read
	{{if .NeedsBVar}}var b []byte{{end}}

    {{range $index, $field := .Fields}}
	// Read {{$field.Name}} ({{$field.Type}})
	{{if eq $field.Type "string"}}
		{{if $field.Length}}
			{{$length := $field.Length | atoi}}
			{{if gt $length 0}}
	b = make([]byte, {{$length}})
	_, err = io.ReadFull(r, b) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (string[{{$length}}]): %w", err)
	}
	s.{{$field.Name}} = string(b)
			{{else}}
	// TODO: Implement reading string field {{$field.Name}} with dynamic length: {{$field.Length}}
	return fmt.Errorf("reading string field {{$field.Name}} with dynamic length '{{$field.Length}}' is not automatically generated") // Returns early
			{{end}}
		{{else}}
	return fmt.Errorf("cannot automatically read string field {{$field.Name}} without a defined length") // Returns early
		{{end}}
	{{else if eq $field.Type "uint8"}}
	var {{$field.Name}}_uint8 uint8
	err = binary.Read(r, binary.LittleEndian, &{{$field.Name}}_uint8) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint8): %w", err)
	}
	s.{{$field.Name}} = {{$field.Name}}_uint8
	{{else if eq $field.Type "uint16"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint16): %w", err)
	}
	{{else if eq $field.Type "uint32"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint32): %w", err)
	}
	{{else if eq $field.Type "int32"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (int32): %w", err)
	}
	{{else if eq $field.Type "[]byte"}}
		{{if $field.Length}}
			{{$length := $field.Length | atoi}}
			{{if gt $length 0}}
	s.{{$field.Name}} = make([]byte, {{$length}})
	_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} ([]byte[{{$length}}]): %w", err)
	}
			{{else}}
	// TODO: Implement reading []byte field {{$field.Name}} with dynamic length: {{$field.Length}}
	return fmt.Errorf("reading []byte field {{$field.Name}} with dynamic length '{{$field.Length}}' is not automatically generated") // Returns early
			{{end}}
		{{else}}
	// This field cannot be read automatically.
	return fmt.Errorf("cannot automatically read []byte field {{$field.Name}} without a defined length") // Returns early
		{{end}}
	{{else}}
	// Unsupported type: {{$field.Type}} for field {{$field.Name}}
	return fmt.Errorf("unsupported type '%s' for field {{$field.Name}} in Read method", "{{$field.Type}}") // Returns early
	{{end}}
    {{end}}

	{{/* Final return nil logic:
	     - If NeedsErrVar is true, it means some operation might have succeeded, so we need return nil.
	     - If NeedsErrVar is false, it means either:
	         a) There were no fields at all.
	         b) All fields generated code that returned early.
	     We need 'return nil' only for case (a).
	*/}}
	{{if .NeedsErrVarRead}}
	// If we reached here, operations using 'err' were successful.
	return nil
	{{else if not .Fields}}
	// No fields in the struct, Read is trivially successful.
	return nil
	{{end}}
	{{/* Implicit: If not .NeedsErrVar and Fields exist, all paths returned early, so no final return nil needed. */}}
}

// Write serializes the struct fields into an io.Writer.
func (s *{{.StructName}}) Write(w io.Writer) error {
	{{if .NeedsErrVarWrite}}var err error{{end}} // Declare err only if needed for Write

    {{range .Fields}}
	// Write {{.Name}} ({{.Type}})
	{{if eq .Type "string"}}
	_, err = w.Write([]byte(s.{{.Name}})) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{.Name}} (string): %w", err)
	}
	// TODO: Add padding if fixed length string is required?
	{{else if eq .Type "uint8"}}
	err = binary.Write(w, binary.LittleEndian, s.{{.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{.Name}} (uint8): %w", err)
	}
	{{else if eq .Type "uint16"}}
	err = binary.Write(w, binary.LittleEndian, s.{{.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{.Name}} (uint16): %w", err)
	}
	{{else if eq .Type "uint32"}}
	err = binary.Write(w, binary.LittleEndian, s.{{.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{.Name}} (uint32): %w", err)
	}
	{{else if eq .Type "int32"}}
	err = binary.Write(w, binary.LittleEndian, s.{{.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{.Name}} (int32): %w", err)
	}
	{{else if eq .Type "[]byte"}}
	_, err = w.Write(s.{{.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{.Name}} ([]byte): %w", err)
	}
	{{else}}
	return fmt.Errorf("unsupported type '%s' for field {{.Name}} in Write method", "{{.Type}}") // Returns early
	{{end}}
    {{end}}

	{{/* Same final return nil logic for Write */}}
	{{if .NeedsErrVarWrite}}
	return nil
	{{else if not .Fields}}
	return nil
	{{end}}
}
`
