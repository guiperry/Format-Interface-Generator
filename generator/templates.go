package generator

// StructTemplate stores the Go code template for the struct
var StructTemplate = `// Code generated by FormatModule tool. DO NOT EDIT.
package {{.PackageName}}

import (
	{{range .Imports}}"{{.}}"
	{{end}}
)

// {{.StructName}} represents the {{.StructName}} structure.
type {{.StructName}} struct {
    {{range .Fields}}
    {{.Name}} {{.Type}} // {{.Description}}
    {{end}}
}

// Read populates the struct fields by reading from an io.Reader, using optional context.
// The context can be used by dynamic length calculations.
func (s *{{.StructName}}) Read(r io.Reader, ctx interface{}) error {
	{{if .NeedsErrVarRead}}var err error{{end}} // Declare err only if needed for Read
	{{if .NeedsBVar}}var b []byte{{end}}

    {{range $index, $field := .Fields}}
	// Read {{$field.Name}} ({{$field.Type}})
	{{if isConditional $field}}
	// Conditional field: {{$field.Name}}
	if {{generateConditionCheck $field.Condition}} {
		{{if eq $field.Type "string"}}
			{{if $field.Length}}
				{{if isExpressionLength $field}}
		// Dynamic length string field: {{$field.Name}} using expression: {{$field.Length}}
		expressionStr := ` + "`{{$field.Length}}`" + ` // Use backticks for raw string literal
		expression, errExpr := govaluate.NewEvaluableExpressionWithFunctions(expressionStr, GetExpressionFunctions())
		if errExpr != nil {
			return fmt.Errorf("parsing length expression for conditional field {{$field.Name}} ('%s'): %w", expressionStr, errExpr)
		}
		parameters := map[string]interface{}{
			"s":   s,   // Pass the current struct instance
			"ctx": ctx, // Pass the context
		}
		evalResult, errEval := expression.Evaluate(parameters)
		if errEval != nil {
			return fmt.Errorf("evaluating length expression for conditional field {{$field.Name}} ('%s'): %w", expressionStr, errEval)
		}
		// Convert result to int (handle potential float64 from evaluator)
		var size int
		switch v := evalResult.(type) {
		case float64: size = int(v)
		case float32: size = int(v)
		case int: size = v
		case int64: size = int(v)
		case int32: size = int(v)
		case uint: size = int(v)
		case uint64: size = int(v)
		case uint32: size = int(v)
		case uint16: size = int(v)
		case uint8: size = int(v)
		default:
			return fmt.Errorf("length expression for conditional field {{$field.Name}} ('%s') evaluated to non-numeric type %T", expressionStr, evalResult)
		}
		if size < 0 {
			return fmt.Errorf("length expression for conditional field {{$field.Name}} ('%s') evaluated to negative size %d", expressionStr, size)
		}
		
		b = make([]byte, size) // Uses b var
		_, err = io.ReadFull(r, b) // Uses err var
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (string[dynamic length %s]): %w", expressionStr, err)
		}
		s.{{$field.Name}} = string(b)
				{{else}}
					{{$length := $field.Length | atoi}}
					{{if gt $length 0}}
		b = make([]byte, {{$length}})
		_, err = io.ReadFull(r, b) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (string[{{$length}}]): %w", err)
		}
		s.{{$field.Name}} = string(b)
					{{else}}
		return fmt.Errorf("invalid length {{$length}} for conditional string field {{$field.Name}}") // Returns early
					{{end}}
				{{end}}
			{{else}}
		return fmt.Errorf("cannot automatically read conditional string field {{$field.Name}} without a defined length") // Returns early
			{{end}}
		{{else if eq $field.Type "uint8"}}
		var {{$field.Name}}_uint8 uint8
		err = binary.Read(r, binary.LittleEndian, &{{$field.Name}}_uint8) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (uint8): %w", err)
		}
		s.{{$field.Name}} = {{$field.Name}}_uint8
		{{else if eq $field.Type "uint16"}}
		err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (uint16): %w", err)
		}
		{{else if eq $field.Type "uint32"}}
		err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (uint32): %w", err)
		}
		{{else if eq $field.Type "int32"}}
		err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} (int32): %w", err)
		}
		{{else if eq $field.Type "[]byte"}}
			{{if $field.Length}}
				{{if isExpressionLength $field}}
		// Dynamic length []byte field: {{$field.Name}} using expression: {{$field.Length}}
		expressionStr := ` + "`{{$field.Length}}`" + ` // Use backticks for raw string literal
		expression, errExpr := govaluate.NewEvaluableExpressionWithFunctions(expressionStr, GetExpressionFunctions())
		if errExpr != nil {
			return fmt.Errorf("parsing length expression for conditional field {{$field.Name}} ('%s'): %w", expressionStr, errExpr)
		}
		parameters := map[string]interface{}{
			"s":   s,   // Pass the current struct instance
			"ctx": ctx, // Pass the context
		}
		evalResult, errEval := expression.Evaluate(parameters)
		if errEval != nil {
			return fmt.Errorf("evaluating length expression for conditional field {{$field.Name}} ('%s'): %w", expressionStr, errEval)
		}
		// Convert result to int (handle potential float64 from evaluator)
		var size int
		switch v := evalResult.(type) {
		case float64: size = int(v)
		case float32: size = int(v)
		case int: size = v
		case int64: size = int(v)
		case int32: size = int(v)
		case uint: size = int(v)
		case uint64: size = int(v)
		case uint32: size = int(v)
		case uint16: size = int(v)
		case uint8: size = int(v)
		default:
			return fmt.Errorf("length expression for conditional field {{$field.Name}} ('%s') evaluated to non-numeric type %T", expressionStr, evalResult)
		}
		if size < 0 {
			return fmt.Errorf("length expression for conditional field {{$field.Name}} ('%s') evaluated to negative size %d", expressionStr, size)
		}
		
		s.{{$field.Name}} = make([]byte, size)
		_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err var
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} ([]byte[dynamic length %s]): %w", expressionStr, err)
		}
				{{else}}
					{{$length := $field.Length | atoi}}
					{{if gt $length 0}}
		s.{{$field.Name}} = make([]byte, {{$length}})
		_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("reading conditional field {{$field.Name}} ([]byte[{{$length}}]): %w", err)
		}
					{{else}}
		return fmt.Errorf("invalid length {{$length}} for conditional []byte field {{$field.Name}}") // Returns early
					{{end}}
				{{end}}
			{{else}}
		// This field cannot be read automatically.
		return fmt.Errorf("cannot automatically read conditional []byte field {{$field.Name}} without a defined length") // Returns early
			{{end}}
		{{else}}
		// Unsupported type: {{$field.Type}} for conditional field {{$field.Name}}
		return fmt.Errorf("unsupported type '%s' for conditional field {{$field.Name}} in Read method", "{{$field.Type}}") // Returns early
		{{end}}
	}
	{{else}}
	{{if eq $field.Type "string"}}
		{{if $field.Length}}
			{{if isExpressionLength $field}}
	// Dynamic length string field: {{$field.Name}} using expression: {{$field.Length}}
	expressionStr := ` + "`{{$field.Length}}`" + ` // Use backticks for raw string literal
	expression, errExpr := govaluate.NewEvaluableExpressionWithFunctions(expressionStr, GetExpressionFunctions())
	if errExpr != nil {
		return fmt.Errorf("parsing length expression for {{$field.Name}} ('%s'): %w", expressionStr, errExpr)
	}
	parameters := map[string]interface{}{
		"s":   s,   // Pass the current struct instance
		"ctx": ctx, // Pass the context
	}
	evalResult, errEval := expression.Evaluate(parameters)
	if errEval != nil {
		return fmt.Errorf("evaluating length expression for {{$field.Name}} ('%s'): %w", expressionStr, errEval)
	}
	// Convert result to int (handle potential float64 from evaluator)
	var size int
	switch v := evalResult.(type) {
	case float64: size = int(v)
	case float32: size = int(v)
	case int: size = v
	case int64: size = int(v)
	case int32: size = int(v)
	case uint: size = int(v)
	case uint64: size = int(v)
	case uint32: size = int(v)
	case uint16: size = int(v)
	case uint8: size = int(v)
	default:
		return fmt.Errorf("length expression for {{$field.Name}} ('%s') evaluated to non-numeric type %T", expressionStr, evalResult)
	}
	if size < 0 {
		return fmt.Errorf("length expression for {{$field.Name}} ('%s') evaluated to negative size %d", expressionStr, size)
	}
	
	b = make([]byte, size) // Uses b var
	_, err = io.ReadFull(r, b) // Uses err var
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (string[dynamic length %s]): %w", expressionStr, err)
	}
	s.{{$field.Name}} = string(b)
			{{else}}
				{{$length := $field.Length | atoi}}
				{{if gt $length 0}}
	b = make([]byte, {{$length}})
	_, err = io.ReadFull(r, b) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (string[{{$length}}]): %w", err)
	}
	s.{{$field.Name}} = string(b)
				{{else}}
	return fmt.Errorf("invalid length {{$length}} for string field {{$field.Name}}") // Returns early
				{{end}}
			{{end}}
		{{else}}
	return fmt.Errorf("cannot automatically read string field {{$field.Name}} without a defined length") // Returns early
		{{end}}
	{{else if eq $field.Type "uint8"}}
	var {{$field.Name}}_uint8 uint8
	err = binary.Read(r, binary.LittleEndian, &{{$field.Name}}_uint8) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint8): %w", err)
	}
	s.{{$field.Name}} = {{$field.Name}}_uint8
	{{else if eq $field.Type "uint16"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint16): %w", err)
	}
	{{else if eq $field.Type "uint32"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (uint32): %w", err)
	}
	{{else if eq $field.Type "int32"}}
	err = binary.Read(r, binary.LittleEndian, &s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} (int32): %w", err)
	}
	{{else if eq $field.Type "[]byte"}}
		{{if $field.Length}}
			{{if isExpressionLength $field}}
	// Dynamic length []byte field: {{$field.Name}} using expression: {{$field.Length}}
	expressionStr := ` + "`{{$field.Length}}`" + ` // Use backticks for raw string literal
	expression, errExpr := govaluate.NewEvaluableExpressionWithFunctions(expressionStr, GetExpressionFunctions())
	if errExpr != nil {
		return fmt.Errorf("parsing length expression for {{$field.Name}} ('%s'): %w", expressionStr, errExpr)
	}
	parameters := map[string]interface{}{
		"s":   s,   // Pass the current struct instance
		"ctx": ctx, // Pass the context
	}
	evalResult, errEval := expression.Evaluate(parameters)
	if errEval != nil {
		return fmt.Errorf("evaluating length expression for {{$field.Name}} ('%s'): %w", expressionStr, errEval)
	}
	// Convert result to int (handle potential float64 from evaluator)
	var size int
	switch v := evalResult.(type) {
	case float64: size = int(v)
	case float32: size = int(v)
	case int: size = v
	case int64: size = int(v)
	case int32: size = int(v)
	case uint: size = int(v)
	case uint64: size = int(v)
	case uint32: size = int(v)
	case uint16: size = int(v)
	case uint8: size = int(v)
	default:
		return fmt.Errorf("length expression for {{$field.Name}} ('%s') evaluated to non-numeric type %T", expressionStr, evalResult)
	}
	if size < 0 {
		return fmt.Errorf("length expression for {{$field.Name}} ('%s') evaluated to negative size %d", expressionStr, size)
	}
	
	s.{{$field.Name}} = make([]byte, size)
	_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err var
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} ([]byte[dynamic length %s]): %w", expressionStr, err)
	}
			{{else}}
				{{$length := $field.Length | atoi}}
				{{if gt $length 0}}
	s.{{$field.Name}} = make([]byte, {{$length}})
	_, err = io.ReadFull(r, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("reading {{$field.Name}} ([]byte[{{$length}}]): %w", err)
	}
				{{else}}
	return fmt.Errorf("invalid length {{$length}} for []byte field {{$field.Name}}") // Returns early
				{{end}}
			{{end}}
		{{else}}
	// This field cannot be read automatically.
	return fmt.Errorf("cannot automatically read []byte field {{$field.Name}} without a defined length") // Returns early
		{{end}}
	{{else}}
	// Unsupported type: {{$field.Type}} for field {{$field.Name}}
	return fmt.Errorf("unsupported type '%s' for field {{$field.Name}} in Read method", "{{$field.Type}}") // Returns early
	{{end}}
	{{end}}
    {{end}}

	{{/* Final return nil logic:
	     - If NeedsErrVar is true, it means some operation might have succeeded, so we need return nil.
	     - If NeedsErrVar is false, it means either:
	         a) There were no fields at all.
	         b) All fields generated code that returned early.
	     We need 'return nil' only for case (a).
	*/}}
	{{if .NeedsErrVarRead}}
	// If we reached here, operations using 'err' were successful.
	return nil
	{{else if not .Fields}}
	// No fields in the struct, Read is trivially successful.
	return nil
	{{end}}
	{{/* Implicit: If not .NeedsErrVar and Fields exist, all paths returned early, so no final return nil needed. */}}
}

// Write serializes the struct fields into an io.Writer.
func (s *{{.StructName}}) Write(w io.Writer) error {
	{{if .NeedsErrVarWrite}}var err error{{end}} // Declare err only if needed for Write

    {{range $index, $field := .Fields}}
	// Write {{$field.Name}} ({{$field.Type}})
	{{if isConditional $field}}
	// Conditional field: {{$field.Name}}
	if {{generateConditionCheck $field.Condition}} {
		{{if eq $field.Type "string"}}
		_, err = w.Write([]byte(s.{{$field.Name}})) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (string): %w", err)
		}
		// TODO: Add padding if fixed length string is required?
		{{else if eq $field.Type "uint8"}}
		err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (uint8): %w", err)
		}
		{{else if eq $field.Type "uint16"}}
		err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (uint16): %w", err)
		}
		{{else if eq $field.Type "uint32"}}
		err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (uint32): %w", err)
		}
		{{else if eq $field.Type "int32"}}
		err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} (int32): %w", err)
		}
		{{else if eq $field.Type "[]byte"}}
		_, err = w.Write(s.{{$field.Name}}) // Uses err
		if err != nil {
			return fmt.Errorf("writing conditional field {{$field.Name}} ([]byte): %w", err)
		}
		{{else}}
		return fmt.Errorf("unsupported type '%s' for conditional field {{$field.Name}} in Write method", "{{$field.Type}}") // Returns early
		{{end}}
	}
	{{else}}
	{{if eq $field.Type "string"}}
	_, err = w.Write([]byte(s.{{$field.Name}})) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (string): %w", err)
	}
	// TODO: Add padding if fixed length string is required?
	{{else if eq $field.Type "uint8"}}
	err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (uint8): %w", err)
	}
	{{else if eq $field.Type "uint16"}}
	err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (uint16): %w", err)
	}
	{{else if eq $field.Type "uint32"}}
	err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (uint32): %w", err)
	}
	{{else if eq $field.Type "int32"}}
	err = binary.Write(w, binary.LittleEndian, s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} (int32): %w", err)
	}
	{{else if eq $field.Type "[]byte"}}
	_, err = w.Write(s.{{$field.Name}}) // Uses err
	if err != nil {
		return fmt.Errorf("writing {{$field.Name}} ([]byte): %w", err)
	}
	{{else}}
	return fmt.Errorf("unsupported type '%s' for field {{$field.Name}} in Write method", "{{$field.Type}}") // Returns early
	{{end}}
	{{end}}
    {{end}}

	{{/* Same final return nil logic for Write */}}
	{{if .NeedsErrVarWrite}}
	return nil
	{{else if not .Fields}}
	return nil
	{{end}}
}
`