// main.go
package generator
// ... (other imports) ...
import (
 // Make sure text/template is imported
)
// ... (constants, FormatConfig struct) ...

// --- NEW: Test Script Template ---
const TestFileTemplate = `// Code generated by FormatModule tool; DO NOT EDIT initially, but MUST be adapted.
package {{.PackageName}}_test // Use _test package convention

import (
	// "bytes" // TODO: Uncomment if using bytes.Equal for verification
	"fmt"
	// "io" // TODO: Uncomment if using io.ReadFull or other io functions
	"os"
	"path/filepath" // For joining paths
	"reflect"
	"testing"

	// Import the package containing the generated code
	"{{.GoModulePath}}/{{.FormatDir}}/{{.PackageName}}" // Adjust GoModulePath if needed
)

// TODO: Adapt this test function for the {{.PackageName}} format.
// - Define realistic sample data for your structs.
// - Implement the logic to write a valid file using your generated Write methods.
// - Implement the logic to read the file back using your generated Read methods.
// - Add specific verification steps using reflect.DeepEqual or bytes.Equal.

// TestGeneratedCode_{{.FirstStructName}} tests the basic Write/Read cycle for the {{.FirstStructName}} struct.
// It's a starting point and likely needs significant modification.
func TestGeneratedCode_{{.FirstStructName}}(t *testing.T) {
	formatName := "{{.PackageName}}"
	testFilename := filepath.Join("testdata", fmt.Sprintf("test_%s_write_read.bin", formatName)) // Store test files in testdata subdir

	// --- Test Data Setup ---
	// TODO: Define meaningful sample data for {{.PackageName}}.{{.FirstStructName}}
	// You might need data for other structs as well depending on the format.
	originalStruct := {{.PackageName}}.{{.FirstStructName}}{
		// Field1: sampleValue1,
		// Field2: sampleValue2,
		// ... add fields based on your {{.FirstStructName}} definition ...
	}
	// TODO: If reading requires context (e.g., for dynamic lengths based on other structs),
	// prepare the necessary context data here.
	// var writeCtx interface{} = nil // TODO: Uncomment and adapt if Write method needs context
	var readCtx interface{} = nil  // Example: No context needed for reading (adapt if needed)


	// --- Ensure testdata directory exists ---
	testDataDir := filepath.Dir(testFilename)
	if err := os.MkdirAll(testDataDir, 0755); err != nil {
		t.Fatalf("Failed to create testdata directory '%s': %v", testDataDir, err)
	}
	// Optional: Clean up the test file afterwards
	// defer os.Remove(testFilename)


	// --- Write Phase ---
	t.Logf("Phase 1: Writing test file %s", testFilename)
	writeFile, err := os.Create(testFilename)
	if err != nil {
		t.Fatalf("Error creating write file '%s': %v", testFilename, err)
	}

	var writeErr error
	func() { // Use closure to ensure file close happens correctly
		defer func() {
			if cerr := writeFile.Close(); cerr != nil && writeErr == nil {
				writeErr = fmt.Errorf("error closing write file: %w", cerr)
			}
		}()

		// TODO: Write all necessary structs/data in the correct order for the format.
		// This likely involves more than just the first struct.
		t.Logf("Writing {{.FirstStructName}}...")
		// TODO: Pass writeCtx if needed by the Write method
		if writeErr = originalStruct.Write(writeFile /*, writeCtx */); writeErr != nil { // Comment out ctx passing
			writeErr = fmt.Errorf("error writing {{.FirstStructName}}: %w", writeErr)
			return
		}
		t.Logf("-> {{.FirstStructName}} written.")

		// TODO: Write other structs or raw data as required by the format.
		// Example:
		// if writeErr = anotherStruct.Write(writeFile); writeErr != nil { ... }
		// if _, writeErr = writeFile.Write(someRawData); writeErr != nil { ... }

	}() // End write closure

	if writeErr != nil {
		t.Fatalf("Write phase failed: %v", writeErr)
	}
	t.Logf("Phase 1: Write completed successfully.")


	// --- Read Phase ---
	t.Logf("Phase 2: Reading test file %s", testFilename)
	readFile, err := os.Open(testFilename)
	if err != nil {
		t.Fatalf("Error opening read file '%s': %v", testFilename, err)
	}

	var readErr error
	readStruct := {{.PackageName}}.{{.FirstStructName}}{}
	// TODO: Declare variables for other structs/data you need to read.

	func() { // Use closure for file close
		defer func() {
			if cerr := readFile.Close(); cerr != nil && readErr == nil {
				readErr = fmt.Errorf("error closing read file: %w", cerr)
			}
		}()

		// TODO: Read all necessary structs/data in the correct order.
		t.Logf("Reading {{.FirstStructName}}...")
		// Pass readCtx if needed by the Read method
		if readErr = readStruct.Read(readFile, readCtx); readErr != nil {
			readErr = fmt.Errorf("error reading {{.FirstStructName}}: %w", readErr)
			return
		}
		t.Logf("-> {{.FirstStructName}} read.")

		// TODO: Read other structs or raw data. Handle dynamic lengths using context if necessary.
		// Example:
		// if readErr = readAnotherStruct.Read(readFile, someContext); readErr != nil { ... }
		// readData := make([]byte, calculatedSize)
		// if _, readErr = io.ReadFull(readFile, readData); readErr != nil { ... } // Requires 'io' import

	}() // End read closure

	if readErr != nil {
		t.Fatalf("Read phase failed: %v", readErr)
	}
	t.Logf("Phase 2: Read completed successfully.")


	// --- Verification Phase ---
	t.Logf("Phase 3: Verifying data...")

	// TODO: Compare all relevant original data with the data read back.
	if !reflect.DeepEqual(originalStruct, readStruct) {
		t.Errorf("Verification FAILED: {{.FirstStructName}} structs do not match.\nOriginal: %+v\nRead:     %+v", originalStruct, readStruct)
	} else {
		t.Logf("-> {{.FirstStructName}} verified.")
	}

	// TODO: Add DeepEqual or bytes.Equal checks for other structs/data.
	// Example:
	// if !reflect.DeepEqual(originalAnotherStruct, readAnotherStruct) { ... }
	// if !bytes.Equal(originalRawData, readData) { ... } // Requires 'bytes' import


	t.Logf("Phase 3: Verification finished for {{.FirstStructName}}.")
	t.Logf("Generated code test for %s completed.", formatName)
}

// TODO: Add more test cases for edge conditions, errors, different variations of the format.
`

// --- Test Template Data Struct ---
type TestTemplateData struct {
	PackageName     string
	FormatDir       string // e.g., "formats"
	FirstStructName string
	GoModulePath    string // The Go module path (e.g., "github.com/yourname/project")
}

// ... (main function, runBootstrap, runGeneration, helpers) ...
