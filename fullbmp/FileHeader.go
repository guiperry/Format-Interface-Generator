// Code generated by FormatModule tool. DO NOT EDIT.
package fullbmp

import (
	"encoding/binary"
	"fmt"
	"io"
	
)

// FileHeader represents the FileHeader structure.
type FileHeader struct {
    
    Signature string // BMP Signature (BM)
    
    FileSize uint32 // Total file size
    
    Reserved1 uint16 // Reserved (0)
    
    Reserved2 uint16 // Reserved (0)
    
    DataOffset uint32 // Offset to image data
    
}

// Read populates the struct fields by reading from an io.Reader.
func (s *FileHeader) Read(r io.Reader) error {
	var err error // Declare err only if needed for Read
	var b []byte

    
	// Read Signature (string)
	
		
			
				
				
	b = make([]byte, 2)
	_, err = io.ReadFull(r, b) // Uses err
	if err != nil {
		return fmt.Errorf("reading Signature (string[2]): %w", err)
	}
	s.Signature = string(b)
				
			
		
	
    
	// Read FileSize (uint32)
	
	err = binary.Read(r, binary.LittleEndian, &s.FileSize) // Uses err
	if err != nil {
		return fmt.Errorf("reading FileSize (uint32): %w", err)
	}
	
    
	// Read Reserved1 (uint16)
	
	err = binary.Read(r, binary.LittleEndian, &s.Reserved1) // Uses err
	if err != nil {
		return fmt.Errorf("reading Reserved1 (uint16): %w", err)
	}
	
    
	// Read Reserved2 (uint16)
	
	err = binary.Read(r, binary.LittleEndian, &s.Reserved2) // Uses err
	if err != nil {
		return fmt.Errorf("reading Reserved2 (uint16): %w", err)
	}
	
    
	// Read DataOffset (uint32)
	
	err = binary.Read(r, binary.LittleEndian, &s.DataOffset) // Uses err
	if err != nil {
		return fmt.Errorf("reading DataOffset (uint32): %w", err)
	}
	
    

	
	
	// If we reached here, operations using 'err' were successful.
	return nil
	
	
}

// Write serializes the struct fields into an io.Writer.
func (s *FileHeader) Write(w io.Writer) error {
	var err error // Declare err only if needed for Write

    
	// Write Signature (string)
	
	_, err = w.Write([]byte(s.Signature)) // Uses err
	if err != nil {
		return fmt.Errorf("writing Signature (string): %w", err)
	}
	// TODO: Add padding if fixed length string is required?
	
    
	// Write FileSize (uint32)
	
	err = binary.Write(w, binary.LittleEndian, s.FileSize) // Uses err
	if err != nil {
		return fmt.Errorf("writing FileSize (uint32): %w", err)
	}
	
    
	// Write Reserved1 (uint16)
	
	err = binary.Write(w, binary.LittleEndian, s.Reserved1) // Uses err
	if err != nil {
		return fmt.Errorf("writing Reserved1 (uint16): %w", err)
	}
	
    
	// Write Reserved2 (uint16)
	
	err = binary.Write(w, binary.LittleEndian, s.Reserved2) // Uses err
	if err != nil {
		return fmt.Errorf("writing Reserved2 (uint16): %w", err)
	}
	
    
	// Write DataOffset (uint32)
	
	err = binary.Write(w, binary.LittleEndian, s.DataOffset) // Uses err
	if err != nil {
		return fmt.Errorf("writing DataOffset (uint32): %w", err)
	}
	
    

	
	
	return nil
	
}
